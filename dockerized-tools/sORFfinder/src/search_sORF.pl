$direc="s";

for(my $i=0; $i<@ARGV; $i++){
        if($ARGV[$i] eq "-m"){
                $MATRIX=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-s"){
                $PP_DST=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-i"){
                $FASTA=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-p"){
                $ratio=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-d"){
                $direc=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-o"){
                $OUT=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
}

if(@ARGV==0){
	print "search_sORF.pl -m matrix_file -s simulation_file -i target_file -o output_file\n";
	print "\n";
	print "---Option----\n";
	print "-m (required) matrix file generated by make_model.pl\n";
	print "-s (required) simulation results generated by simulate.pl\n";
	print "-i (required) target input sequences\n";
	print "-o (required) output file\n";
	print "-p (required) proportion(p) of coding sequence in genome(0.01<p<0.5): should be the same value used in simulation_file\n";
	print "-d only sens(s) or both sens and antisens(b): defalt is only sens direction\n";
	exit 1;
}
for(my $i=0; $i<@ARGV; $i++){
        if($ARGV[$i]!=-1){
		print "search_sORF.pl -m matrix_file -s simulation_file -i target_file -o output_file\n";
		print "\n";
		print "---Option----\n";
		print "-m (required) matrix file generated by make_model.pl\n";
		print "-s (required) simulation results generated by simulate.pl\n";
		print "-i (required) target input sequences\n";
		print "-o (required) output file\n";
		print "-p proportion(p) of coding sequence in genome(0.01<p<0.5): defalt is 0.5\n";
		print "-d only sens(s) or both sens and antisens(b): defalt is only sens direction\n";
		exit 1;
        }
}
if($OUT eq ""){
	print "please put name of output\n";
	exit 1;
}
unless(-f $PP_DST){
        print "can not find file (simulation results): $PP_DST\n";
        exit 1;
}
unless(-f $MATRIX){
        print "can not find file (matrix): $MATRIX\n";
        exit 1;
}
unless(-f $FASTA){
        print "can not find file (input sequences): $FASTA\n";
        exit 1;
}
if($ratio<0.01 or $ratio>0.5){
        print "the proportion(p) of coding sequence is not correct range. Please use the range(0.01<p<0.5)\n";
        exit 1;
}
unless($direc eq "s" or $direc eq "b"){
        print "direction should be s(only sens) or b(both sens and anti-sens) direction\n";
        exit 1;
}
if(-f $OUT){
        unlink $OUT;
}

$ORDER =5;

%aalist = qw(
atg	M	tat     Y	gca     A       gcc     A
gcg     A       gct     A	tgc     C       tgt     C
gac     D       gat     D	gaa     E       gag     E
ttt     F       ttc     F	gga     G       ggc     G
ggg     G       ggt     G	cac     H       cat     H
ata     I       atc     I	att     I       aaa     K
aag     K       tta     L	ttg     L       cta     L
ctc     L       ctg     L	ctt     L       tgg     W
aac     N       aat     N	cca     P       ccc     P
ccg     P       cct     P	caa     Q       cag     Q
aga     R       agg     R	cga     R       cgc     R
cgg     R       cgt     R	agc     S       agt     S
tca     S       tcc     S	tcg     S       tct     S
aca     T       acc     T	acg     T       act     T
gta     V       gtc     V	gtg     V       gtt     V
tac     Y	taa	.	tag     .       tga     .
);

##
open(IN, $MATRIX);
while(<IN>){
	if(/^Order\s\=\s(\d+),\sFrame\s+\=\s+(\d+)/){
		$order=$1;
		$frame=$2;
	}
	elsif(/^([ATGC]+)\s+\d+\s+\((\d+\.\d{4})/){
		$matrix=$order.$frame;
		$$matrix{$1}=$2;
	}
}
close IN;

open(IN, $PP_DST);
while(<IN>){
	if(/^(\d+)\s+NCDS\s+(\S.*)\n/){
		$len=$1;
		@ncds_p=split(/\s+/,$2);
		@ncds_p=sort {$b<=>$a} @ncds_p;
		$SUM=0;
		for(my $n=5; $n<15; $n++){
			$SUM=$SUM+$ncds_p[$n];
		}
		$AV=$SUM/10;
		$FalseP{$len}=$AV;
	}
	if(/^(\d+)\s+CDS\s+(\S.*)\n/){
		$len=$1;
		@cds_p=split(/\s+/,$2);
		@cds_p=sort {$a<=>$b} @cds_p;
		$SUM=0;
		for(my $n=5; $n<15; $n++){
			$SUM=$SUM+$cds_p[$n];
		}
		$AV=$SUM/10;
		$FalseN{$len}=$AV;
		$PP=join(",",@cds_p);
		$PP_cds{$len}=$PP;
	}
}
close IN;

########## MAIN ##########
open(in, $FASTA);
while(<in>){
	if(/^>(\S+)/){
		$name=$1;
		push(@NAME,$name);
	}
	elsif(/(\S+)/){
		$SEQ{$name}=$SEQ{$name}.$1;
	}
}
close in;

undef @R_name;
undef @R_dir;
undef @R_site;
undef @R_score;
undef @R_seq;

$total=0;
for(my $i=0; $i<@NAME; $i++){
	$otu=$NAME[$i]; 
	if($direc eq "s" or $direc eq "b"){
		$frame_seq=substr($SEQ{$otu},0);
		($S,$I)=&orf60($otu, $frame_seq);
		&coding_sORF($NAME[$i],$S,$I,"+",0);

		$frame_seq=substr($SEQ{$otu}, 1);
		($S,$I)=&orf60($otu, $frame_seq);
		&coding_sORF($NAME[$i],$S,$I,"+",1);

		$frame_seq=substr($SEQ{$otu}, 2);
		($S,$I)=&orf60($otu, $frame_seq);
		&coding_sORF($NAME[$i],$S,$I,"+",2);
	}
	if($direc eq "b"){
		$length_seq=length($SEQ{$otu});

		$frame_seq=substr(&reverse_seq($SEQ{$otu}),0);
		($S,$I)=&orf60($otu, $frame_seq);
		$last_site=$length_seq-0;
		&coding_sORF($NAME[$i],$S,$I,"-",$last_site);

		$frame_seq=substr(&reverse_seq($SEQ{$otu}),1);
		($S,$I)=&orf60($otu, $frame_seq);
		$last_site=$length_seq-1;
		&coding_sORF($NAME[$i],$S,$I,"-",$last_site);

		$frame_seq=substr(&reverse_seq($SEQ{$otu}),2);
		($S,$I)=&orf60($otu, $frame_seq);
		$last_site=$length_seq-2;
		&coding_sORF($NAME[$i],$S,$I,"-",$last_site);
	}
}

sub coding_sORF{
	my $N=shift; my $S=shift; my $I=shift;
	my $D=shift; my $Start=shift;
	@tmp_s=@$S; @tmp_i=@$I;
	for(my $n=0; $n<@tmp_s; $n++){
		$l=length($tmp_s[$n])-3;
		if($l<29){next;}
		if($l>302){next;}
		$total++;

		$SEQ=substr($tmp_s[$n], 0, -3) ;
		$ci=&PP_calc($SEQ);
		if($ci>$FalseP{$l} and $ci>$FalseN{$l}){
			if($D eq "+"){
				$TMP_I=$tmp_i[$n]+$Start;
			}
			elsif($D eq "-"){
				$TMP_I=$Start-$tmp_i[$n];
			}

			@pp=split(/,/,$PP_cds{$l});
			$pp_s=0;
			for(my $s=0; $s<@pp; $s++){
				if($pp[$s]<=$ci){$pp_s++;}
			}
			$PP_S=int($pp_s*1000/@pp+0.5)/10;
			push(@R_name, $N);
			push(@R_dir, $D);
			push(@R_site, $TMP_I);
			push(@R_score,$PP_S);
			push(@R_seq,  $tmp_s[$n]);
		}
	}
}

open(out, "> $OUT");
if($direc eq "s"){
	if(@R_name==0){
		print out "There is No small ORF with coding potential on only sens sequence\n";
	}
	else{
		$num=@R_name;
		print out "## Find total $total sORF in only sens sequences\n";
		print out "## Identify $num coding sORF\n";
		print out "## fasta format of coding sORF ---";
		print out "## Name is \"Seq_name#Start_site#Direction#Score\"\n";

		for(my $i=0; $i<@R_name; $i++){
			print out ">$R_name[$i]#$R_site[$i]#$R_dir[$i]#$R_score[$i]\n";
			&seq60($R_seq[$i]);
		}
	}
	close out;
}
elsif($direc eq "b"){
	if(@R_name==0){
		print out "There is No small ORF with coding potential on both sens and anti-sens sequence\n";
	}
	else{
		$num=@R_name;
		print out "## Find total $total sORF on both sens and anti-sens sequences\n";
		print out "## Identify $num coding sORF\n";
		print out "## fasta format of coding sORF ---";
		print out "## Name is \"Seq_name#Site#Direction#Score\"\n";

		for(my $i=0; $i<@R_name; $i++){
			print out ">$R_name[$i]#$R_site[$i]#$R_dir[$i]#$R_score[$i]\n";
			&seq60($R_seq[$i]);
		}
	}
	close out;
}

sub seq60{
        my ($aa_seq);
        $aa_seq=shift;
        while($aa_seq ne "" ){
                $b = substr ($aa_seq, 0, 60);
                $aa_seq = substr ($aa_seq,60);
                print out "$b\n";
        }
}

sub orf60{
	my($otu, $frame, $seq, $aa_seq, $num);
	$otu=shift; $seq=shift;
	undef $aa_seq; $num=0; undef @A_seq; undef @S_site;
	undef $start;
	for(my $i=0; $i <= length($seq)/3; $i++){
		$cod = substr($seq, $i*3,3);
		$cod =~ tr/A-Z/a-z/;
		$not_det=0;
		if($cod =~ /[atgc]{3}/){
			$not_det=1;
		}
		if($aalist{$cod} eq "M" and $start eq ""){
			$start=$i;
		}
		if($not_det==0){
			undef $aa_seq;
			undef $start;
		}
		if($not_det==1 and $start ne ""){
			$aa_seq = $aa_seq.$cod;
		}
		if($aalist{$cod} eq "."){
			 if(length($aa_seq)>32){
				$aa_seq =~ tr/a-z/A-Z/;
				push(@A_seq, $aa_seq);
				push(@S_site,$start*3);
			}
			undef $aa_seq; undef $start;
		}
	}
	return(\@A_seq,\@S_site);	
}

sub reverse_seq{
	my ($seq, $real_seq, @nor_seq, @rev_seq);
	undef $real_seq; undef @nor_seq; undef @rev_seq;
	$seq=shift;
	@nor_seq=split(//, $seq);
	@rev_seq = reverse @nor_seq;
	for(my $i =0; $i < @rev_seq; $i++){
		if(($rev_seq[$i] eq "A") or ($rev_seq[$i] eq "a")){
			$real_seq = $real_seq."T";	
		}
		if(($rev_seq[$i] eq "T") or ($rev_seq[$i] eq "t")){
			$real_seq = $real_seq."A";	
		}
		if(($rev_seq[$i] eq "G") or ($rev_seq[$i] eq "g")){
			$real_seq = $real_seq."C";	
		}
		if(($rev_seq[$i] eq "C") or ($rev_seq[$i] eq "c")){
			$real_seq = $real_seq."G";	
		}
	}
	return ($real_seq);
}

sub chech_seq{
        my ($seq, @nu);
        $seq=shift;
        @nu=split(//, $seq);
        $sign=1;
        for(my $i=0; $i<@nu; $i++){
                if($nu[$i]=~/[ATGC]/){
                }
                else{
                        $sign=-1;
                }
        }
        return($sign);
}
			
sub PP_calc{
	my($TARGET, $sign, $first_F, $order, @PFC, $ci);
	$sign=0; undef @PFC;

	$TARGET=shift;

	$sign=&chech_seq($TARGET);
	if($sign==1){
		$ci=0;
		$S=0;
		$target_win=substr($TARGET,$S,30);
		while(length($target_win)>=30){
			for(my $frame=0; $frame<=6; $frame++){
				$first_F=substr($target_win, 0, $ORDER);
				$order=$ORDER-1;
				$matrix=$order.$frame;
				$PFC[$frame]=$$matrix{$first_F};
			}
			for(my $frame=0; $frame<=6; $frame++){
				for(my $k=0; $k<30-$ORDER; $k++){
					$F=substr($target_win, $k, $ORDER);
					$next_NT=substr($target_win, $k+$ORDER, 1);

					if($frame==0){$nextframe=0;}
					elsif(1<=$frame and $frame <=3){$nextframe=($frame-1+$k)%3+1;}
					elsif(4<=$frame and $frame <=6){$nextframe=($frame-4+$k)%3+4;}
					$matrix=$ORDER.$nextframe; $SEG=$F."A";  $probA=$$matrix{$SEG};
					$matrix=$ORDER.$nextframe; $SEG=$F."T";  $probT=$$matrix{$SEG};
					$matrix=$ORDER.$nextframe; $SEG=$F."G";  $probG=$$matrix{$SEG};
					$matrix=$ORDER.$nextframe; $SEG=$F."C";  $probC=$$matrix{$SEG};
	
					if($probA>=0 and $probT>=0 and $probG>=0 and $probC>=0){
						$sigma=$probA+$probT+$probG+$probC;
						if($sigma==0){
							$condprob=0.001;
						}
						elsif($next_NT eq "A"){
							$condprob=$probA/$sigma;
						}
						elsif($next_NT eq "T"){
							$condprob=$probT/$sigma;
						}
						elsif($next_NT eq "G"){
							$condprob=$probG/$sigma;
						}
						elsif($next_NT eq "C"){
							$condprob=$probC/$sigma;
						}
						else{
							die "stop 1\n";
						}
					}		
					else{
						die "stop 2\n";
					}
					$PFC[$frame]=$PFC[$frame]*$condprob;
				}
			}
			for(my $frame=0; $frame<=6; $frame++){
				$A=1/(1-$ratio);
				$B=6/$ratio;
				if($frame==0){ $div = $PFC[$frame]/$A;}
				else{ $div = $div+$PFC[$frame]/$B;}
			}
			if($PFC[0]==0 and $PFC[1]==0 and $PFC[2]==0 and $PFC[3]==0 and $PFC[4]==0 and $PFC[5]==0 and $PFC[6]==0){
				$S=$S+3;
				$target_win=substr($TARGET,$S,30);
				next;
			}
			@PP=($PFC[0]/$A/$div,$PFC[1]/$B/$div,$PFC[2]/$B/$div,$PFC[3]/$B/$div,$PFC[4]/$B/$div,$PFC[5]/$B/$div,$PFC[6]/$B/$div);
			$ci=$ci+$PFC[1]/$B/$div;
			$S=$S+3;
			$target_win=substr($TARGET,$S,30);
		}
		return($ci);
	}
	else{
		return(-1);
	}
}

